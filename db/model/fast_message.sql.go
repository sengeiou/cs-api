// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: fast_message.sql

package model

import (
	"context"
	"time"

	"cs-api/pkg/types"
)

const countListFastMessage = `-- name: CountListFastMessage :one
select count(*)
from fast_message
where IF(@title is null, 0, title) like IF(@title is null, 0, CONCAT('%', @title, '%'))
  and IF(@content is null, 0, content) like IF(@content is null, 0, CONCAT('%', @content, '%'))
  and IF(@status is null, 0, status) = IF(@status is null, 0, @status)
`

func (q *Queries) CountListFastMessage(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countListFastMessageStmt, countListFastMessage)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFastMessage = `-- name: CreateFastMessage :exec
INSERT INTO fast_message (category_id, title, content, status, created_by, created_at, updated_by, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFastMessageParams struct {
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	CreatedBy  int64        `db:"created_by" json:"created_by"`
	CreatedAt  time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateFastMessage(ctx context.Context, arg CreateFastMessageParams) error {
	_, err := q.exec(ctx, q.createFastMessageStmt, createFastMessage,
		arg.CategoryID,
		arg.Title,
		arg.Content,
		arg.Status,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedBy,
		arg.UpdatedAt,
	)
	return err
}

const deleteFastMessage = `-- name: DeleteFastMessage :exec
DELETE
FROM fast_message
WHERE id = ?
`

func (q *Queries) DeleteFastMessage(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteFastMessageStmt, deleteFastMessage, id)
	return err
}

const getAllAvailableFastMessage = `-- name: GetAllAvailableFastMessage :many
SELECT fast_message.id, fast_message.category_id, fast_message.title, fast_message.content, fast_message.status, fast_message.created_by, fast_message.created_at, fast_message.updated_by, fast_message.updated_at, constant.value AS category
FROM fast_message
         INNER JOIN constant ON constant.id = fast_message.category_id
WHERE status = 1
`

type GetAllAvailableFastMessageRow struct {
	ID         int64        `db:"id" json:"id"`
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	CreatedBy  int64        `db:"created_by" json:"created_by"`
	CreatedAt  time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
	Category   string       `db:"category" json:"category"`
}

func (q *Queries) GetAllAvailableFastMessage(ctx context.Context) ([]GetAllAvailableFastMessageRow, error) {
	rows, err := q.query(ctx, q.getAllAvailableFastMessageStmt, getAllAvailableFastMessage)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAvailableFastMessageRow{}
	for rows.Next() {
		var i GetAllAvailableFastMessageRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Title,
			&i.Content,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFastMessage = `-- name: GetFastMessage :one
SELECT id, category_id, title, content, status, created_by, created_at, updated_by, updated_at
FROM fast_message
WHERE id = ? LIMIT 1
`

func (q *Queries) GetFastMessage(ctx context.Context, id int64) (FastMessage, error) {
	row := q.queryRow(ctx, q.getFastMessageStmt, getFastMessage, id)
	var i FastMessage
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Title,
		&i.Content,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const listFastMessage = `-- name: ListFastMessage :many
select fast_message.id, fast_message.category_id, fast_message.title, fast_message.content, fast_message.status, fast_message.created_by, fast_message.created_at, fast_message.updated_by, fast_message.updated_at, constant.value AS category
from fast_message
         inner join constant on constant.id = fast_message.category_id
where IF(@title is null, 0, title) like IF(@title is null, 0, CONCAT('%', @title, '%'))
  and IF(@content is null, 0, content) like IF(@content is null, 0, CONCAT('%', @content, '%'))
  and IF(@status is null, 0, status) = IF(@status is null, 0, @status) limit ?
offset ?
`

type ListFastMessageParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListFastMessageRow struct {
	ID         int64        `db:"id" json:"id"`
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	CreatedBy  int64        `db:"created_by" json:"created_by"`
	CreatedAt  time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
	Category   string       `db:"category" json:"category"`
}

func (q *Queries) ListFastMessage(ctx context.Context, arg ListFastMessageParams) ([]ListFastMessageRow, error) {
	rows, err := q.query(ctx, q.listFastMessageStmt, listFastMessage, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFastMessageRow{}
	for rows.Next() {
		var i ListFastMessageRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Title,
			&i.Content,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFastMessage = `-- name: UpdateFastMessage :exec
UPDATE fast_message
SET category_id = ?,
    title       = ?,
    content     = ?,
    status      = ?,
    updated_by  = ?,
    updated_at  = ?
WHERE id = ?
`

type UpdateFastMessageParams struct {
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
	ID         int64        `db:"id" json:"id"`
}

func (q *Queries) UpdateFastMessage(ctx context.Context, arg UpdateFastMessageParams) error {
	_, err := q.exec(ctx, q.updateFastMessageStmt, updateFastMessage,
		arg.CategoryID,
		arg.Title,
		arg.Content,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
