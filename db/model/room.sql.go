// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: room.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"cs-api/pkg/types"
)

const acceptRoom = `-- name: AcceptRoom :exec
UPDATE room SET staff_id = ?, status = 2 WHERE id = ?
`

type AcceptRoomParams struct {
	StaffID int64 `db:"staff_id" json:"staff_id"`
	ID      int64 `db:"id" json:"id"`
}

func (q *Queries) AcceptRoom(ctx context.Context, arg AcceptRoomParams) error {
	_, err := q.exec(ctx, q.acceptRoomStmt, acceptRoom, arg.StaffID, arg.ID)
	return err
}

const closeRoom = `-- name: CloseRoom :exec
UPDATE room SET tag_id = ?, closed_at = ?, status = 3 WHERE id = ?
`

type CloseRoomParams struct {
	TagID    int64        `db:"tag_id" json:"tag_id"`
	ClosedAt sql.NullTime `db:"closed_at" json:"closed_at"`
	ID       int64        `db:"id" json:"id"`
}

func (q *Queries) CloseRoom(ctx context.Context, arg CloseRoomParams) error {
	_, err := q.exec(ctx, q.closeRoomStmt, closeRoom, arg.TagID, arg.ClosedAt, arg.ID)
	return err
}

const countClosedRoomByTag = `-- name: CountClosedRoomByTag :many
select tag_id, COUNT(*) AS Count
from room
where status = 3 and closed_at between ? and ?
group by tag_id
`

type CountClosedRoomByTagParams struct {
	ClosedAt   sql.NullTime `db:"closed_at" json:"closed_at"`
	ClosedAt_2 sql.NullTime `db:"closed_at_2" json:"closed_at_2"`
}

type CountClosedRoomByTagRow struct {
	TagID int64 `db:"tag_id" json:"tag_id"`
	Count int64 `db:"count" json:"count"`
}

// 計算每日分類諮詢數
func (q *Queries) CountClosedRoomByTag(ctx context.Context, arg CountClosedRoomByTagParams) ([]CountClosedRoomByTagRow, error) {
	rows, err := q.query(ctx, q.countClosedRoomByTagStmt, countClosedRoomByTag, arg.ClosedAt, arg.ClosedAt_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CountClosedRoomByTagRow{}
	for rows.Next() {
		var i CountClosedRoomByTagRow
		if err := rows.Scan(&i.TagID, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const countDailyRoomByMember = `-- name: CountDailyRoomByMember :one
select COUNT(distinct member_id) AS GuestCount
from room
where created_at between ? and ?
group by member_id
`

type CountDailyRoomByMemberParams struct {
	CreatedAt   time.Time `db:"created_at" json:"created_at"`
	CreatedAt_2 time.Time `db:"created_at_2" json:"created_at_2"`
}

// 計算每日訪客數
func (q *Queries) CountDailyRoomByMember(ctx context.Context, arg CountDailyRoomByMemberParams) (int64, error) {
	row := q.queryRow(ctx, q.countDailyRoomByMemberStmt, countDailyRoomByMember, arg.CreatedAt, arg.CreatedAt_2)
	var guestcount int64
	err := row.Scan(&guestcount)
	return guestcount, err
}

const countListRoom = `-- name: CountListRoom :one
select count(*)
from room
where IF(@roomId is null, 0, room.id) = IF(@roomId is null, 0, @roomId)
  and IF(@staffId is null, 0, staff_id) = IF(@staffId is null, 0, @staffId)
  and IF(@status is null, 0, room.status) = IF(@status is null, 0, @status)
`

func (q *Queries) CountListRoom(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countListRoomStmt, countListRoom)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countListStaffRoom = `-- name: CountListStaffRoom :one
select count(*)
from room
where status = ?
  and IF(@staffId is null, 0, staff_id) = IF(@staffId is null, 0, @staffId)
`

func (q *Queries) CountListStaffRoom(ctx context.Context, status types.RoomStatus) (int64, error) {
	row := q.queryRow(ctx, q.countListStaffRoomStmt, countListStaffRoom, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createRoom = `-- name: CreateRoom :execresult
INSERT INTO room (staff_id, member_id, created_at, updated_at)
VALUES (?, ?, ?, ?)
`

type CreateRoomParams struct {
	StaffID   int64     `db:"staff_id" json:"staff_id"`
	MemberID  int64     `db:"member_id" json:"member_id"`
	CreatedAt time.Time `db:"created_at" json:"created_at"`
	UpdatedAt time.Time `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateRoom(ctx context.Context, arg CreateRoomParams) (sql.Result, error) {
	return q.exec(ctx, q.createRoomStmt, createRoom,
		arg.StaffID,
		arg.MemberID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const getMemberAvailableRoom = `-- name: GetMemberAvailableRoom :one
SELECT id, staff_id, member_id, tag_id, score, status, created_at, updated_at, closed_at FROM room where member_id = ? and status <> 3 LIMIT 1
`

// 獲取會員並未關閉的房間
func (q *Queries) GetMemberAvailableRoom(ctx context.Context, memberID int64) (Room, error) {
	row := q.queryRow(ctx, q.getMemberAvailableRoomStmt, getMemberAvailableRoom, memberID)
	var i Room
	err := row.Scan(
		&i.ID,
		&i.StaffID,
		&i.MemberID,
		&i.TagID,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
	)
	return i, err
}

const getRoom = `-- name: GetRoom :one
SELECT room.id, room.staff_id, room.member_id, room.tag_id, room.score, room.status, room.created_at, room.updated_at, room.closed_at, member.name AS member_name
FROM room
INNER JOIN member ON member.id = room.member_id
WHERE room.id = ? LIMIT 1
`

type GetRoomRow struct {
	ID         int64            `db:"id" json:"id"`
	StaffID    int64            `db:"staff_id" json:"staff_id"`
	MemberID   int64            `db:"member_id" json:"member_id"`
	TagID      int64            `db:"tag_id" json:"tag_id"`
	Score      int32            `db:"score" json:"score"`
	Status     types.RoomStatus `db:"status" json:"status"`
	CreatedAt  time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt  time.Time        `db:"updated_at" json:"updated_at"`
	ClosedAt   sql.NullTime     `db:"closed_at" json:"closed_at"`
	MemberName string           `db:"member_name" json:"member_name"`
}

func (q *Queries) GetRoom(ctx context.Context, id int64) (GetRoomRow, error) {
	row := q.queryRow(ctx, q.getRoomStmt, getRoom, id)
	var i GetRoomRow
	err := row.Scan(
		&i.ID,
		&i.StaffID,
		&i.MemberID,
		&i.TagID,
		&i.Score,
		&i.Status,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ClosedAt,
		&i.MemberName,
	)
	return i, err
}

const getStaffRoom = `-- name: GetStaffRoom :many
SELECT id FROM room where staff_id = ? and status <> 3
`

func (q *Queries) GetStaffRoom(ctx context.Context, staffID int64) ([]int64, error) {
	rows, err := q.query(ctx, q.getStaffRoomStmt, getStaffRoom, staffID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []int64{}
	for rows.Next() {
		var id int64
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoom = `-- name: ListRoom :many
select room.id,
       room.status,
       room.created_at,
       room.closed_at,
       COALESCE(staff.name, '') as staff_name,
       member.name              as member_name,
       COALESCE(tag.name, '')   as tag_name
from room
         left join staff on staff.id = room.staff_id
         left join tag on tag.id = room.tag_id
         inner join member on member.id = room.member_id
where IF(@roomId is null, 0, room.id) = IF(@roomId is null, 0, @roomId)
  and IF(@staffId is null, 0, staff_id) = IF(@staffId is null, 0, @staffId)
  and IF(@status is null, 0, room.status) = IF(@status is null, 0, @status) limit ?
offset ?
`

type ListRoomParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListRoomRow struct {
	ID         int64            `db:"id" json:"id"`
	Status     types.RoomStatus `db:"status" json:"status"`
	CreatedAt  time.Time        `db:"created_at" json:"created_at"`
	ClosedAt   sql.NullTime     `db:"closed_at" json:"closed_at"`
	StaffName  string           `db:"staff_name" json:"staff_name"`
	MemberName string           `db:"member_name" json:"member_name"`
	TagName    string           `db:"tag_name" json:"tag_name"`
}

func (q *Queries) ListRoom(ctx context.Context, arg ListRoomParams) ([]ListRoomRow, error) {
	rows, err := q.query(ctx, q.listRoomStmt, listRoom, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListRoomRow{}
	for rows.Next() {
		var i ListRoomRow
		if err := rows.Scan(
			&i.ID,
			&i.Status,
			&i.CreatedAt,
			&i.ClosedAt,
			&i.StaffName,
			&i.MemberName,
			&i.TagName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStaffRoom = `-- name: ListStaffRoom :many
select room.id, room.status, member.name as member_name
from room
         inner join member on member.id = room.member_id
where room.status = ?
  and IF(@staffId is null, 0, staff_id) = IF(@staffId is null, 0, @staffId) limit ?
offset ?
`

type ListStaffRoomParams struct {
	Status types.RoomStatus `db:"status" json:"status"`
	Limit  int32            `db:"limit" json:"limit"`
	Offset int32            `db:"offset" json:"offset"`
}

type ListStaffRoomRow struct {
	ID         int64            `db:"id" json:"id"`
	Status     types.RoomStatus `db:"status" json:"status"`
	MemberName string           `db:"member_name" json:"member_name"`
}

func (q *Queries) ListStaffRoom(ctx context.Context, arg ListStaffRoomParams) ([]ListStaffRoomRow, error) {
	rows, err := q.query(ctx, q.listStaffRoomStmt, listStaffRoom, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListStaffRoomRow{}
	for rows.Next() {
		var i ListStaffRoomRow
		if err := rows.Scan(&i.ID, &i.Status, &i.MemberName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateRoomScore = `-- name: UpdateRoomScore :exec
UPDATE room SET score = ? WHERE id = ? and status = 2
`

type UpdateRoomScoreParams struct {
	Score int32 `db:"score" json:"score"`
	ID    int64 `db:"id" json:"id"`
}

func (q *Queries) UpdateRoomScore(ctx context.Context, arg UpdateRoomScoreParams) error {
	_, err := q.exec(ctx, q.updateRoomScoreStmt, updateRoomScore, arg.Score, arg.ID)
	return err
}

const updateRoomStaff = `-- name: UpdateRoomStaff :exec
update room
set staff_id = ?
where id = ?
`

type UpdateRoomStaffParams struct {
	StaffID int64 `db:"staff_id" json:"staff_id"`
	ID      int64 `db:"id" json:"id"`
}

func (q *Queries) UpdateRoomStaff(ctx context.Context, arg UpdateRoomStaffParams) error {
	_, err := q.exec(ctx, q.updateRoomStaffStmt, updateRoomStaff, arg.StaffID, arg.ID)
	return err
}
