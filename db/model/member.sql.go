// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: member.sql

package model

import (
	"context"
	"database/sql"
	"time"

	"cs-api/pkg/types"
)

const countListMember = `-- name: CountListMember :one
select count(*)
from member
where IF(@mobile is null, 0, mobile) like IF(@mobile is null, 0, CONCAT(@mobile, '%')) COLLATE utf8mb4_general_ci
  and IF(@email is null, 0, email) like IF(@email is null, 0, CONCAT(@email, '%')) COLLATE utf8mb4_general_ci
`

func (q *Queries) CountListMember(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countListMemberStmt, countListMember)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMember = `-- name: CreateMember :execresult
INSERT INTO member (type, name, device_id, created_at, updated_at)
VALUES (?, ?, ?, ?, ?)
`

type CreateMemberParams struct {
	Type      types.MemberType `db:"type" json:"type"`
	Name      string           `db:"name" json:"name"`
	DeviceID  string           `db:"device_id" json:"device_id"`
	CreatedAt time.Time        `db:"created_at" json:"created_at"`
	UpdatedAt time.Time        `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateMember(ctx context.Context, arg CreateMemberParams) (sql.Result, error) {
	return q.exec(ctx, q.createMemberStmt, createMember,
		arg.Type,
		arg.Name,
		arg.DeviceID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
}

const getGuestMember = `-- name: GetGuestMember :one
select id, type, name, device_id, real_name, mobile, email, online_status, created_at, updated_at
from member
where type = 2
  and device_id = ? LIMIT 1
`

func (q *Queries) GetGuestMember(ctx context.Context, deviceID string) (Member, error) {
	row := q.queryRow(ctx, q.getGuestMemberStmt, getGuestMember, deviceID)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.DeviceID,
		&i.RealName,
		&i.Mobile,
		&i.Email,
		&i.OnlineStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getNormalMember = `-- name: GetNormalMember :one
select id, type, name, device_id, real_name, mobile, email, online_status, created_at, updated_at
from member
where type = 1
  and name = ? LIMIT 1
`

func (q *Queries) GetNormalMember(ctx context.Context, name string) (Member, error) {
	row := q.queryRow(ctx, q.getNormalMemberStmt, getNormalMember, name)
	var i Member
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Name,
		&i.DeviceID,
		&i.RealName,
		&i.Mobile,
		&i.Email,
		&i.OnlineStatus,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOnlineStatus = `-- name: GetOnlineStatus :one
select online_status
from member
where id = ?
`

func (q *Queries) GetOnlineStatus(ctx context.Context, id int64) (types.MemberOnlineStatus, error) {
	row := q.queryRow(ctx, q.getOnlineStatusStmt, getOnlineStatus, id)
	var online_status types.MemberOnlineStatus
	err := row.Scan(&online_status)
	return online_status, err
}

const listMember = `-- name: ListMember :many
select id, type, name, device_id, real_name, mobile, email, online_status, created_at, updated_at
from member
where IF(@mobile is null, 0, mobile) like IF(@mobile is null, 0, CONCAT(@mobile, '%')) COLLATE utf8mb4_general_ci
  and IF(@email is null, 0, email) like IF(@email is null, 0, CONCAT(@email, '%')) COLLATE utf8mb4_general_ci limit ?
offset ?
`

type ListMemberParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) ListMember(ctx context.Context, arg ListMemberParams) ([]Member, error) {
	rows, err := q.query(ctx, q.listMemberStmt, listMember, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Member{}
	for rows.Next() {
		var i Member
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Name,
			&i.DeviceID,
			&i.RealName,
			&i.Mobile,
			&i.Email,
			&i.OnlineStatus,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateOnlineStatus = `-- name: UpdateOnlineStatus :exec
update member
set online_status = ?
where id = ?
`

type UpdateOnlineStatusParams struct {
	OnlineStatus types.MemberOnlineStatus `db:"online_status" json:"online_status"`
	ID           int64                    `db:"id" json:"id"`
}

func (q *Queries) UpdateOnlineStatus(ctx context.Context, arg UpdateOnlineStatusParams) error {
	_, err := q.exec(ctx, q.updateOnlineStatusStmt, updateOnlineStatus, arg.OnlineStatus, arg.ID)
	return err
}
