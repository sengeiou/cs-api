// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.13.0
// source: fast_reply.sql

package model

import (
	"context"
	"time"

	"cs-api/pkg/types"
)

const countListFastReply = `-- name: CountListFastReply :one
select count(*)
from fast_reply
where IF(@title is null, 0, title) like IF(@title is null, 0, CONCAT('%', @title, '%')) COLLATE utf8mb4_general_ci
  and IF(@content is null, 0, content) like IF(@content is null, 0, CONCAT('%', @content, '%')) COLLATE utf8mb4_general_ci
  and IF(@status is null, 0, status) = IF(@status is null, 0, @status)
`

func (q *Queries) CountListFastReply(ctx context.Context) (int64, error) {
	row := q.queryRow(ctx, q.countListFastReplyStmt, countListFastReply)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createFastReply = `-- name: CreateFastReply :exec
INSERT INTO fast_reply (category_id, title, content, status, created_by, created_at, updated_by, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?)
`

type CreateFastReplyParams struct {
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	CreatedBy  int64        `db:"created_by" json:"created_by"`
	CreatedAt  time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateFastReply(ctx context.Context, arg CreateFastReplyParams) error {
	_, err := q.exec(ctx, q.createFastReplyStmt, createFastReply,
		arg.CategoryID,
		arg.Title,
		arg.Content,
		arg.Status,
		arg.CreatedBy,
		arg.CreatedAt,
		arg.UpdatedBy,
		arg.UpdatedAt,
	)
	return err
}

const deleteFastReply = `-- name: DeleteFastReply :exec
DELETE
FROM fast_reply
WHERE id = ?
`

func (q *Queries) DeleteFastReply(ctx context.Context, id int64) error {
	_, err := q.exec(ctx, q.deleteFastReplyStmt, deleteFastReply, id)
	return err
}

const getAllAvailableFastReply = `-- name: GetAllAvailableFastReply :many
SELECT fast_reply.id, fast_reply.category_id, fast_reply.title, fast_reply.content, fast_reply.status, fast_reply.created_by, fast_reply.created_at, fast_reply.updated_by, fast_reply.updated_at, constant.value AS category
FROM fast_reply
         INNER JOIN constant ON constant.id = fast_reply.category_id
WHERE status = 1
`

type GetAllAvailableFastReplyRow struct {
	ID         int64        `db:"id" json:"id"`
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	CreatedBy  int64        `db:"created_by" json:"created_by"`
	CreatedAt  time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
	Category   string       `db:"category" json:"category"`
}

func (q *Queries) GetAllAvailableFastReply(ctx context.Context) ([]GetAllAvailableFastReplyRow, error) {
	rows, err := q.query(ctx, q.getAllAvailableFastReplyStmt, getAllAvailableFastReply)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GetAllAvailableFastReplyRow{}
	for rows.Next() {
		var i GetAllAvailableFastReplyRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Title,
			&i.Content,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFastReply = `-- name: GetFastReply :one
SELECT id, category_id, title, content, status, created_by, created_at, updated_by, updated_at
FROM fast_reply
WHERE id = ? LIMIT 1
`

func (q *Queries) GetFastReply(ctx context.Context, id int64) (FastReply, error) {
	row := q.queryRow(ctx, q.getFastReplyStmt, getFastReply, id)
	var i FastReply
	err := row.Scan(
		&i.ID,
		&i.CategoryID,
		&i.Title,
		&i.Content,
		&i.Status,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedBy,
		&i.UpdatedAt,
	)
	return i, err
}

const listFastReply = `-- name: ListFastReply :many
select fast_reply.id, fast_reply.category_id, fast_reply.title, fast_reply.content, fast_reply.status, fast_reply.created_by, fast_reply.created_at, fast_reply.updated_by, fast_reply.updated_at, constant.value AS category
from fast_reply
         inner join constant on constant.id = fast_reply.category_id
where IF(@title is null, 0, title) like IF(@title is null, 0, CONCAT('%', @title, '%')) COLLATE utf8mb4_general_ci
  and IF(@content is null, 0, content) like IF(@content is null, 0, CONCAT('%', @content, '%')) COLLATE utf8mb4_general_ci
  and IF(@status is null, 0, status) = IF(@status is null, 0, @status) limit ?
offset ?
`

type ListFastReplyParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

type ListFastReplyRow struct {
	ID         int64        `db:"id" json:"id"`
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	CreatedBy  int64        `db:"created_by" json:"created_by"`
	CreatedAt  time.Time    `db:"created_at" json:"created_at"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
	Category   string       `db:"category" json:"category"`
}

func (q *Queries) ListFastReply(ctx context.Context, arg ListFastReplyParams) ([]ListFastReplyRow, error) {
	rows, err := q.query(ctx, q.listFastReplyStmt, listFastReply, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListFastReplyRow{}
	for rows.Next() {
		var i ListFastReplyRow
		if err := rows.Scan(
			&i.ID,
			&i.CategoryID,
			&i.Title,
			&i.Content,
			&i.Status,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedBy,
			&i.UpdatedAt,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateFastReply = `-- name: UpdateFastReply :exec
UPDATE fast_reply
SET category_id = ?,
    title       = ?,
    content     = ?,
    status      = ?,
    updated_by  = ?,
    updated_at  = ?
WHERE id = ?
`

type UpdateFastReplyParams struct {
	CategoryID int64        `db:"category_id" json:"category_id"`
	Title      string       `db:"title" json:"title"`
	Content    string       `db:"content" json:"content"`
	Status     types.Status `db:"status" json:"status"`
	UpdatedBy  int64        `db:"updated_by" json:"updated_by"`
	UpdatedAt  time.Time    `db:"updated_at" json:"updated_at"`
	ID         int64        `db:"id" json:"id"`
}

func (q *Queries) UpdateFastReply(ctx context.Context, arg UpdateFastReplyParams) error {
	_, err := q.exec(ctx, q.updateFastReplyStmt, updateFastReply,
		arg.CategoryID,
		arg.Title,
		arg.Content,
		arg.Status,
		arg.UpdatedBy,
		arg.UpdatedAt,
		arg.ID,
	)
	return err
}
